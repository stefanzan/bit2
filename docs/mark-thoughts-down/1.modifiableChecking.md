Date: 2024-10-20
Benchmark caes: Velocity4.bit2
## Problem

Given the following example:

`«var users=["Alice", "Bob"]»
«var counter=0»
«for user in users»«counter»«counter=counter+1»
«endfor»`

The generated text is:
`

0
1
`

Supporse we change the index starting from 1, by updating with two replacement operations (bulk(replace "0" with "1" at 2, replace "1" with "2" at 4)), suprisingly the backward transformation will fail.

I will show you why by firstly giving the lambdalized ehanced result as follows:

\users.[["\n", 
    \counter. [[
      "\n", 
      loopfront "", 
      \user.[[
        (counter,0), \counter.[[
          "\n",
          separator "",
          \user.[[
            (counter, 1), \counter.[["\n"]] (counter+1, 2)
          ]] "Bob"
        ]] (counter+1, 1)
      ]] "Alice"
      , looprear ""
    ]] (0, 0)
 ]] ["Alice", "Bob"]

 The problem occurs at the inner most lambda application of the counter assignment: \counter.[["\n"]] (counter+1, 2)
 
 At the moment, the environment is updated to { counter -> (2, 2)}  by the second replacement statement.
 While in the body of the inner most lambda applicaiton, there is no occurance of variable counter, current implmentation consider the counter valule unmodifiable which is 2, so for `fuseExp`, it is in the form of: 2 |> {counter -> (2,2)} |- counter +1 ---> {counter -> (2,2)} |- counter + 0, which is wrong.


Let's consider another update operations: Supporse we change the second index to 0 too, by updating with one replacement operation (bulk(replace "1" with "0" at 4)).
The inner most exp's update would be:
2 |> {counter -> (0,0)} |- counter+1 ---> {counter -> (0,0)} |- counter+2 

The wanted one is counter+0, not counter+2.

## One possible solution

In fact, the value on the left of |> before feeding to fuseExp in the environment is {counter -> (2,[])}, which means it is not updated in the body expression of the lambda application. But if we use 2 to udpate the exp counter+1, which adds an inherently knowledge that 2 must be the updated value.

For `ExpNode`s:

```
export interface ExpNode {
    type: 'exp';
    binding: Binding;
}
```

Add an extra attribute to mark it is updated or not.
```
export interface ExpNode {
    type: 'exp';
    binding: Binding;
    isUpdated: boolean;
}
```
During merging of loopitems, if there is ExpNode that not been updated, then we accept the loopitem of updated ExpNode.
If both are not updated, then keep as it is.